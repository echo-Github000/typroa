### 问题点

1. 设备离线状态不准确，解决方案涉及多网关，需确认最新方案

   ：方案已确认，网关重启15分钟之后发送子设备信息查询，云端回复后网关本地对比，将不在线的设备logout；若该子设备绑定到其他的网关上，那么该网关上报的logout并不会引起云端的状态改变，因为云端会判断他们根本不在一个网关上。（待实现）

2. 产品表动态创建问题，不能依赖mapping文件创建，需启动时平台那边将产品信息传递过来，接口已实现

   ：产品表的创建，大部分参数都需要云端来传递，如果一部分云传递一部分mapping文件获得，显得臃肿，不如从云端给全部参数。（待实现）

3. 本地优先逻辑（待定）

4. 多网关协同问题，涉及局域网内部多网关通讯，以及协议制定

   多网关自动发现：通过ssdp协议可以实现多网关之间的相互发现（UDP组播）

   选举机制：

   		1. 根据能力（优先）
   		1. 能力相同，根据负载（device_table的子设备数量）
   		1. 上述相同则随机选举

​		重新选举机制：

```
	1. 同能力网关尽量不切换主从
	2. 不同能力网关，一定以能力高的网关为主
```







#### 云端与网关子设备状态同步

##### 背景：

​		由于一些特殊情况，如子设备断电后，网关立马重启，由于监测机制的局限性，云端有时并不知道网关离线了，自然该断电的子设备在云端就一直处于在线状态，而网关侧已经没有了该子设备，两侧的子设备状态不符。经讨论确认使用gateway.subdevice.info消息向云端获取网关的子设备，并在回复中新增子设备的online状态字段，用于网关本地子设备状态同步

##### 具体策略：

  		1. 查询子设备状态时机：每次重启或者重新联网后，在9次recheck_all_sub_dev完成之后发送该消息向云端查询。该时机保证大部分的子设备均可以连上网关，在睡眠中尚未连上的后面有其他策略处理。
  		2. 两侧同步逻辑：网关收到云端回复的子设备并保存在本地静态数组；module_zb_manage每两分钟去检查是否收到云端回复的消息，收到云端消息后将云端设备与本地dev_table的子设备进行check；







1. 一次全构建属性的回复，如果大小大于一个接收缓冲包，就在发送接口中自动分包发送

2. 构建时就检查包的长度，如果长度大于一个接受包，就先发一部分，再发另一部分

   因为也维护了设备的msg缓冲大小和接收缓存是一样大的，所以超过了接收缓存也就超过了设备的msg缓存，故只能采用2方式

   因为算出包的大小略有困难，所以可以考虑依照属性的条目来判断是否分包，可以一次构建好多个包，然后放在重传列表中







1. 子设备解绑，场景没有同步更新
2. lan线程的创建要等云端指定设备角色之后
3. 网关本身属性需开机时上报云端，同时同步到本地cached列表中



