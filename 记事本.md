## 记事本

#### 2022-06-01

1. 入职资料填写，走OA相关流程
2. 了解ZigBee协议
3. 和同事了解具体的工作内容以及工作环境的搭建

#### 06-02

1. 了解ZigBee协议，了解蓝牙mesh
2. 了解JNI接口

#### 06-06

1. 查看冰哥分享的网关相关的文档（协议相关以及代码介绍）
2. 申请办公的相关账号，包含：gitlab、viki 、jira
3. clone了网关代码并初步浏览了代码框架，各目录功能、线程创建方法、MQTT协议相关代码逻辑等
4. 走了一个产品领用流程，用于项目开发工作

#### 06-07

1. 山哥给讲解了代码结构
2. 查看了云米协议以及代码相关的介绍文档和PPT
3. 安装Java的jdk,版本18；安装Android studio并安装插件NDK和cmake等

#### 06-08

1. 浏览ZB module的相关代码框架
2. 经山哥讲解了解了云米lot平台的使用，包含产品的物模型、profile（json文件）以及设备的状态信息查看等（用于查看设备状态和调试）
3. 拉了Android demo的代码，并将viomi_proxyd文件夹里的文件copy到viotlink_gateway_android_demo\app\src\main\jni\viot_link文件夹里用于编译so库，代码编译成功

#### 06-09

1. 阅读代码架构，大致了解各module的作用
2. 了解设备注册到网关的粗流程
3. 了解zigbee和viot协议之间的转换实质
4. 了解各module之间的交互方式，采用message queue以及module function的方法
5. 了解message queue在各模块之间进行消息传递的逻辑

#### 06-10

1. 收到网关新产品，并完成配置，通过adb connect连接到该设备
2. 根据设备动作的日志（logcat）简单了解了过程中发送的MQTT消息内容及格式
3. 了解JNI的接口，包含Java端调用原生端的native方法和原生端回调Java端的callback方法

#### 06-13

1. 查看网关代码，了解相关指令的具体流程走向
2. 了解viot与zigbee之间的协议转换
3. 了解了上层应用与模组之间的交互方法，串口方式

#### 06-14

1. 从命令流的流向来分析网关的工作过程，包括网关的主动获取子设备状态值以及子设备主动报告状态值的变化
2. 浏览云米iot云平台，熟悉设备与云端是之间的交互关系
3. 画了一个命令流的流程图以便于分析网关的工作过程
4. 了解了两个关键接口：vlink_recv和vlink_send，前者是通过JNI接口将数据写进列表，vlink端异步获取到上层数据，并下发到底层；后者是通过JNI接口的cb方法将数据直接发送到上层，Android端的接口为：ext_android_gw_publish_cb

#### 06-15

1. 了解单个属性，组属性，批量属性之前的联系，其中冗余代码太多，可考虑将其缩减为一个接口，可从规范请求命令的格式来解决
2. 添加额外的日志输出，并编译成SO库替换到pad中，查看具体的事物逻辑关系
3. 发现cmd的指令逻辑问题，网关端尚未收到子设备的反馈结果就直接将结果发到了云端，实际上只是vlink端收到这个消息而已

#### 06-16

1. 在zb设备列表中新增人体传感器的附加属性
2. 根据产品定义修改json文件的新增属性内容

#### 06-20

1. 添加人体雷达传感器到网关，查看日志熟悉新设备入网的具体流程，并使用串口指令模拟传感器状态变化，查看与网关端交互以及网关端相应的处理逻辑
2. 由于so文件的目录会变化，导致批处理执行错误，新增shell脚本去获取这个文件的目录，每次push前先获取文件所在目录

#### 06-21

1. 验证人体传感器功能和场景开关的初始状态值，同时熟悉上下行命令流向以及详细交互流程

#### 06-22

1. 绘制云端，网关以及子设备之间的命令流流向示意图；
2. 绘制子设备入网的详细流程图
3. 查找网关设备中对应SO库在程序运行中所占用的栈大小：目前只能看到其所属进程的物理地址和虚拟地址大小，以及so库的代码段和数据段在进程地址空间里的位置和大小

#### 06-23

1. 代码中新增一个module MAP模块用于分析com.viomi.homepad进程的map文件，从而评判是否有内存泄漏问题，但目前只是打印出map文件的内容，如指令 cat /proc/pid/map一样。
2. 搭建zigbee dongle抓包的PC环境，并抓取一些属性变化的数据包，与网关端数据做对比，熟悉子设备与网关端的交互细节

#### 06-24

1. 了解各设备（网关，WiFi设备，云等）在MQTT协议中的角色，熟悉消息订阅与发布的具体流程，了解MQTT协议的代码实现。
2. 编写统计libviotlink_a.so库文件占用静态内存大小的代码，包括代码段大小以及数据段大小等

#### 06-27

1. 了解上层协议的zigbee相关指令能成功送达子设备的保证机制（zb_need_confirmed_cmd_list_xxx），捋清指令丢失重传的详细实现过程。
2. 了解动态链接库的加载流程，动态链接库在虚拟内存中分配的位置（内存映射段）及内存占用情况
3. pull本地场景代码，尝试了解相关流程

#### 06-29

1. 编写网关统计动态内存使用情况的代码，初步统计动态内存占用60K+

#### 06-30

1. 修改并提交网关代码，将malloc、MDF_MALLOC等接口替换为VIOMI_MALLOC等，用于统计网关整个运行期间的动态内存占用，统计功能默认关闭，需要时添加宏HEAP_INFO_DEBUG即可。

#### 07-01

1. 同步替换viotlink_gateway_android_demo代码的malloc等接口为VIOMI_MALLOC等，统计总的动态内存占用情况
2. pull app的代码，配置环境并编译带有本地场景的app，测试执行本地场景时的动态内存开销情况
3. 目前json中尚有部分malloc接口未替换，仅如下文件未替换：cJSON.c

#### 07-04

1. 完善统计堆内存使用的相关代码，了解调用栈回溯的实现方法。

#### 07-06

1. 完成初步数据迁移功能的代码编写，当前简单验证迁移过去的数据可生效，待后期大量验证。

#### 07-07

1. 基本完成数据迁移的代码编写，并完成简单验证
2. 新增malloc等函数调用时callstack的打印，便于后期分析内存问题

#### 07-08

1. 测试数据迁移的代码
2. 编写解析callstack文件分析内存占用的exe程序

#### 07-11

1. 完善callstack的trace打印功能并提交相关代码
2. 安装python3的开发环境（pycharm）, 熟悉python的语法格式，使用pyechart绘制库简单实现折线图的绘制，后期欲用于绘制heap内存使用情况图表

#### 07-12

1. 编写代码分析并输出疑似内存泄露的函数调用栈，方便后期查找内存问题

#### 07-14

1. 编写解析回调栈的脚本工具，并上传日志文件解析的源码到gitlab，解析工具制作基本完成，后期欲用python解析内存碎片化
2. 熟悉本地场景的业务逻辑，逐个了解每个接口的具体功能

#### 07-15

1. 总结编写内存工具时所遇到的困难和解决方法，以及过程中使用的新知识点，并输出文档
2. 学习本地场景的业务逻辑，了解断网时子设备入网和属性变化后场景执行的详细过程，并绘制了包含断网情况下，子设备入网的流程图上传到viki

#### 07-18

1. 查看网关离线时，本地场景执行的日志，分析本地场景执行的详细逻辑
2. 发现堆内存trace输出在json.c中快速打印的时候会出现乱序的情况，即先打印了free，随后才打印了malloc，后面考虑在trace输出的时候加锁

#### 07-20

1. 增加本地场景情况下，设备拓扑状态的check，以及及时更新设备的topo状态，防止离线状态下设备离开，再重新上线时无法通知云端

#### 07-26

1. 优化网关设备初始化时频繁对子设备进行get_attribute操作，新增report_attribute的判断，如果子设备上报过属性，网关便不再发送对应设备的get_attribute命令

   

#### 08-01

1. 优化子设备入网时，mapping文件的获取方式，由于现在新增了mapping文件的本地存储，在get_mapping，拿到url地址时，判断mapping文件的版本号是否高于本地mapping，如果高于便重新保存到数据库，如果小于或等于，便优先使用本地的mapping文件，减少了获取mapping文件的时长以及提升了系统的速度。

#### 08-03

1. 新增attribute_report_value表的动态维护功能，避免每次添加新设备，网关侧都需要添加对应的report_value

   ```C
   简而言之：通过新增mapping文件中的zigbee相关属性来动态填充与zgb_attr_report_value_list表属性相同的attribute_report表
   
   具体实现逻辑：
   1. 依然维持旧表不变，以向前兼容之前产品的mapping
   
   2. 新产品的mapping新增zigbee的cluster、attribute等属性，以及一个动态配置功能的标识属性
   
   3. 根据mapping文件创建产品节点时，判断是否存在动态配置功能标识来动态填充一个与zgb_attr_report_value_list表相同属性的attribute_report表
   
   4. 需要查表时先查attribute_report表，再查zgb_attr_report_value_list表
   ```

#### 08-04

1. 修复子设备断电，网关立马重启后，造成云端子设备一直处于在线的错误状态

   ```
   实现方案：
   在网关重启一段时间后以及断网后重新联网时，判断存储于flash中的device_table中的设备是否已经成功创建了设备节点childnode，如果创建了，表明该设备已上线，如果没有对应的节点，那表明这个设备“可能”已经离线了（如果这个设备没离线，那就是心跳时间太久了），这时便向云端发送logout的消息
   ```

   

#### 08-19

1. 完成多网关之间多播发现，本地选举master，以及单播通讯等基本通讯功能的验证

   ```
   存在的问题：
   1. 代码的逻辑太紧密，耦合性强，应重构松耦合，尽量少些依赖
   2. 本地选举的算法需进一步优化，不仅仅知道自己的角色还要知道其他网关的角色
   ```

2. 优化云端与网关端子设备状态不同步的问题，采用gateway.subdevice.info信息同步两端状态

#### 09-26

1. 从设备中子设备解绑，状态变更，灯组新增等需要通知master，消息dev_list_changed已经做好，待在相应位置添加变更消息的发送

#### 09-27

1. 每次发的设备列表都应该是全量的

   

#### 09-28

1. lan_scene的场景获取基于local的cb新增一个参数用于标志是lan场景还是local场景
2. 约定设备角色的json字符串格式
3. 设备向平台拉取master角色策略：所有设备都向平台拉取，但是如果该设备不是平台指定的master就暂不回复该消息，等到平台指定的设备去拉去master角色时，并待master设备创建socket成功后回复平台，这时平台可以回复其他设备的角色请求消息。
4. pad端添加局域网内其他网关的设备卡片后，在pad端执行与网关对应的接口：1. 对应设备或者一个设备表的设备对应状态；2. 获取某个设备或者某一组设备的属性；3. set_properties和action
5. pad端添加局域网内场景卡片后，

#### 09-30

1. 在电脑端编写一个虚拟的控制器来控制这个设备
2. 节后任务：1. 和pad端的两个接口，fetch lan scene & master; 2. pad端上报初始值时不触发场景执行；3. 主从获取master的策略，以及如何周期fetch场景等（可以先将线程都跑起来，再创建socket时额外加一些限制条件；4. 绑定时，不保存get_all_properties的众多属性值；5. 动态的扩展和缩减接收buff大小

#### 10-08

1. pad上报属性初始值不触发场景做法：local_scene_self_device_change_notify新增一个参数用于判断是否触发场景，该参数标识两个状态，一个为开机pad自动报的属性，一个是人为click后发生的属性变化。

#### 10-09

1. 新增局域网场景变更消息mesh.lan.scene.update，网关端已修改，需pad端添加该消息的透传。

#### 10-11

1. properties changed 和event report，向云端上报时需要新增一个标志属性用于判别本地执行，从而云端规避
2. 之前的local中的offline限制应该去除，而且局域网的策略应该同样适用于同网关的执行策略
3. 解决同一个设备多个did所引起的异常下线问题，兼容老设备

#### 10-12

1. 绑定设备成功后就重启？（新版OS bug，待验证）
2. 

#### 10-18

1. 本地场景变更未通知，待解决
2. pad端获取执行策略已增加
3. 网关启动报告按键的初始属性已新增
4. 云端下发指令尚未带context

#### 10-19

1. 本地场景变更通知已做，但主网关无论是同网关场景变化还是局域网场景变化，都采用mesh.lan.scene.update消息通知，已反馈，待解决

2. ota_dev_info更新网络状态变换信息（为什么相同局域网下获取的key不同）

   由于平台尚未收到网关更新的IP信息，所以平台上这多个网关并不在同一局域网，自然返回的key也就不同了

3. 切换网络获取空的场景列表（目前的解决方案是等待30秒后再去获取场景列表）

   

#### 10-21

1. 切换网络时导致网关上下线，平台即刻回复网关主网关的信息，但是平台回复给网关的主网关IP是旧的IP，可能是与目前新连上的WiFi ip是不相同的，考虑云端是否可以增加延时通知或者不通知。目前本地的容错策略为：检测到网络变化会在变化的30秒后拉一次主网关信息，这时平台的信息应该就和本地一致了，多网关便可以同步相同的信息，但是在这30秒内多网关通信可能存在一些错误。

#### 11-11

1. "目前网关重启时，子设备上线后从子设备获取或主动上报的属性还没有采用all properties report方式上报，这个也是一个后面需要推敲的地方"，这种情况只需要通过all properties report上报给云端即可，从不需要发给主，主会自己去拉

学习蓝牙mesh的相关技术流程，熟悉竞品mesh网关设备的技术方案以及实现难点

熟悉网关关于mesh功能的相关代码实现，了解相关流程

处理主从网关重启或网络状态变化引起的，子设备属性变化可能引起局域网场景执行的问题

排查和分析homepad S子设备异常掉线的问题

测试局域网场景中，常见的业务流程处理是否完备，以及是否存在异常

#### 11-16

1. 目前开发这边使用的网关did: 1111424118, 1111424116,  1111428200
2. 测试同学使用的网关did：1111424125，1111424126
3. 测试同学遇到的问题：解绑后重新绑定，网关的单播socket一直不创建。
4. 解决局域网场景中，网关云端离线，从网关未能将属性同步给主网关，从而导致场景执行失败
5. 解决场景执行时，网关误将自己的按键属性为子设备的属性，导致找不到相关属性，造成场景执行失败
6. 评估IP变化引起的局域网场景变化为普通场景，导致的局域网场景列表为空，场景无法执行的问题，认为应该自动重新变为局域网场景较好，同时局域网中一个网关解绑，也会导致场景失效，建议自动恢复
7. 

#### 11-17

1. 解决主网关解绑后重新绑定，单播socket始终未创建的问题
2. 维护测试环境网关did的使用情况
3. 解决场景执行时涉及pad自身属性时，处理逻辑中没有回复消息确认的问题
4. 局域网场景云端离线情况下，使用回环的场景执行进行压力测试

#### 11-19

1. 排查并解决场景相关的内存泄漏问题

#### 11-20

1. bt mesh模组相关问题讨论
2. 去除场景开关功能
3. 

#### 12-07

1. 本地场景合入主线，打包app给测试同事测试
2. 

#### 12-08

1. 与app对接接口以及修改详情
2. 添加scene日志的类型字段
3. 排查用户提到的子设备未成功删除的问题

#### 12-15

1. mesh协议学习ϡ
2. 学习mesh相关代码流程

#### 12-16

1. 离线情况下，发送设备拓扑查询，没有回复后，就掉不到使用本地mapping的地方，所以没法添加这个设备
2. 排查并解决线上问题：子设备异常解绑

#### 12-26 

1. 若没有属性，get_all_properties填充属性后返回
2. 记的明超之前说过，plus不管是有线开关还是场景按键都会将初始属性下发给我们
3. 组播应该是可以接收到，你遇到的问题应该是不同账户下其他网关发的组播消息
4. 关于homepad S的场景执行问题，我不是很清楚，因为我没用过，可以先升级app看看
5. 同网关的场景同时被同网关和多网关线程执行，这个应该是后台判断场景归属出错了
6. 确认后台是否正确处理了带context字段的消息



#### 01-04

1. 本地场景建立socket连接之后到向从网关获取子设备列表的时间间隔太短了
2. 网关云端离线重启的情况下，某些子设备在使用本地mapping上线时，并不上报其一些关键的初始属性，或者说某次重启，子设备上线报的是关键初始属性，有时报的则是心跳属性
3. 考虑云端离线情况，对子设备关键初始属性的获取



#### 01-05

1. 对于网关离线重启的情况下，同类型的设备仅有第一个可以成功创建childnode，其他的设备均不可以，导致设备无法控制
2. 由于某些问题导致对端收到重复的局域网消息，导致某些动作的执行频繁，目前采用消息去重的方式解决

#### 01-11

1. keycode296与297的长按事件处理问题
2. homepad的系统crash问题
3. homepad的点击网关提示未联网的问题



#### 01-17

1. 部分子设备离线问题：1.考虑是离线情况下，从网关下的某个设备没有上报有效属性，导致主网关认为该子设备离线，（如果是此情况，可点击下这个设备报一下有效属性可恢复）；2.考虑是路由器拔掉网线到pad检测网络断开的时间较长，导致较长时间没有恢复局域网通讯，造成部分子设备离线不可控，（如果是此情况，等待一段时间便可以正常上线执行了）；3.考虑是网关so问题，待排查
2. 切换WiFi后断网，导致的主网关信息未能即使同步到各网关，引起一些通讯上的错误：1.云端做完备的在线状态判断再选主网关和下发master信息；2.网关so兼容这个错误，同步并切换主的信息

#### 01-28

1. 子设备部分离线问题跟进
2. 查找设备属性上报时，提示找不到对应的属性和pid



