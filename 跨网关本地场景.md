#### 跨网关本地场景

规则：

1. 主不向从设备发送自己的子设备属性状态变更，只有从向主设备发送
2. 



若设备5要控制设备1和3的打开：5设备上报属性，slaver2通过单播向master发送子设备属性变化，master查找本地跨网关场景列表，查看是否有该动作的关联场景，这时查到本地3设备关联了场景，结合本地保存的该设备状态进行相关执行，同时也检测到该动作也与slaver1的设备1相关联，查看master本地保存的设备1状态，如果状态不一，将指令通过单播发送给slaver1进行执行





#### 单播接口：

接口原型：

```
unicast_send（struct lan_local_info_t lan_local_info, char *data, size_t size）
```

接口的定义：应该是一个黑盒子，只要有数据通过该接口发出去即可，不用了解要发给谁。要<font color='red'> 发送的数据应该保存在链表中 </font>维护（用于重传），线程异步调用单播接口取链表中数据并发送

接口应该具有的功能：

1. 判断本机是主还是从
2. 根据入参的data来确定要发送的目的IP，是多个还是单个
3. 有重传的机制
4. 若有新的指令类型，应易添加（抽象不变和异变内容）
5. 若有新的lan_local_info_t成员变量添加，也应可用，不应涉及到该接口的修改（做好封装）
6. 发送消息时，应该<font color='red'> 发送一个随消息次数不断累加的整数 </font>，接收者收到这样的消息后回同样的整数，这样发送者便可以知道这个消息已经成功送达，并将本地链表中的数据删除；各网关不用同步这个值，自己维护自己的就行，这个值也应在链表中维护（写链表时）
7. 数据包应鉴定是reply的还是对方主动发的

